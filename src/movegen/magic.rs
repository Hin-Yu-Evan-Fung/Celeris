//! # Module: `magic`
//!
//! This module provides supporting structures and functions for magic bitboards, specifically
//! focusing on calculating the necessary parameters (`mask`, `shift`, `offset`) for magic lookups
//! once the magic numbers themselves are known.
//!
//! ## Overview
//!
//! Magic bitboards are a technique for efficiently calculating sliding piece attacks (bishops, rooks).
//! This module defines the `Magic` struct which holds the parameters needed for the lookup calculation
//! for a single square. It also provides the `populate_magic_table` function, which computes these
//! parameters for all squares using pre-generated magic numbers provided by the `lookup` module
//! (which, in turn, gets them from the compile-time generated `magic_table.rs`).
//!
//! The actual attack tables (`BISHOP_TABLE`, `ROOK_TABLE`) and the magic numbers themselves
//! (`BISHOP_MAGIC_NUMS`, `ROOK_MAGIC_NUMS`) are generated by the `build.rs` script at compile time
//! and included directly into the `lookup` module. This module (`magic`) primarily deals with
//! preparing the `Magic` structs needed to *use* those tables.
//!
//! ## Key Components
//!
//! - **`Magic`**: A struct holding the magic number, mask, shift, and offset for a specific square,
//!   used to calculate the index into the precomputed attack tables.
//! - **`MagicTable`**: A type alias for an array `[Magic; Square::NUM]`, holding the `Magic` entry
//!   for each square on the board.
//! - **`attacks_on_the_fly`**: A `const fn` that calculates sliding piece attacks without magic
//!   bitboards. Used internally by `populate_magic_table` to determine the correct masks.
//! - **`populate_magic_table`**: A `const fn` that initializes the `MagicTable` for a given piece
//!   type (Bishop or Rook). It uses the pre-generated magic numbers (`BISHOP_MAGIC_NUMS` or
//!   `ROOK_MAGIC_NUMS` from the `lookup` module) and `attacks_on_the_fly` to compute the
//!   `mask`, `shift`, and `offset` for each square's `Magic` entry.
//! - **`get_edge_mask`**: A `const fn` helper that returns a bitboard representing the board edges,
//!   used during mask calculation.
//!
//! ## Usage
//!
//! The primary output of this module used elsewhere is the `MagicTable` generated by
//! `populate_magic_table`. This table (`BISHOP_MAGICS`, `ROOK_MAGICS` in the `lookup` module)
//! is used in conjunction with the compile-time generated attack tables (`BISHOP_TABLE`, `ROOK_TABLE`)
//! within the `slider_attack` function in `lookup.rs` to perform the fast attack lookups.

use super::lookup::{BISHOP_MAGIC_NUMS, ROOK_MAGIC_NUMS}; // Import the compile-time generated magic numbers
use crate::core::*;

/******************************************\
|==========================================|
|             Magics Definition            |
|==========================================|
\******************************************/

/// Holds the necessary parameters for magic bitboard lookups for a single square.
#[derive(Debug, Default, Clone, Copy)]
pub(crate) struct Magic {
    /// The pre-generated magic number for this square and piece type.
    pub(crate) magic: u64,
    /// The bitmask representing relevant blockers for this square.
    pub(crate) mask: Bitboard,
    /// The right-shift amount to apply after multiplying by the magic number.
    pub(crate) shift: u8,
    /// The base offset into the global attack table (`BISHOP_TABLE` or `ROOK_TABLE`).
    pub(crate) offset: usize,
}

impl Magic {
    /// A constant representing an uninitialized `Magic` entry.
    pub(crate) const EMPTY: Magic = Magic {
        magic: 0,
        mask: Bitboard::EMPTY,
        shift: 0,
        offset: 0,
    };

    /// Calculates the index into the precomputed attack table.
    ///
    /// `occ` should represent the occupied squares on the board.
    /// The formula is `((occ & mask) * magic) >> shift + offset`.
    #[inline]
    pub(crate) const fn index(self, occ: Bitboard) -> usize {
        // Note: Using wrapping_mul for the multiplication as standard practice in magic bitboards.
        ((occ.bitand(self.mask).0.wrapping_mul(self.magic)) >> self.shift) as usize + self.offset
    }
}

/// Magic tables: An array containing a `Magic` entry for each square.
pub type MagicTable = [Magic; Square::NUM];

/******************************************\
|==========================================|
|            Attacks on the fly            |
|==========================================|
\******************************************/

/// Calculates sliding piece attacks without using magic bitboards.
///
/// This is a relatively slow approach used during the compile-time calculation
/// within `populate_magic_table` to determine the correct `mask` for each square.
///
/// # Arguments
/// * `pt`: The `PieceType` (must be `Rook` or `Bishop`).
/// * `sq`: The `Square` the piece is on.
/// * `occ`: A `Bitboard` representing occupied squares (blockers).
///
/// # Returns
/// A `Bitboard` of attacked squares.
pub(crate) const fn attacks_on_the_fly(pt: PieceType, sq: Square, occ: Bitboard) -> Bitboard {
    use Direction::*;
    // Directions for rook and bishop
    let dirs: [Direction; 4] = match pt {
        PieceType::Rook => [N, E, W, S],
        PieceType::Bishop => [NE, NW, SE, SW],
        _ => unreachable!(), // Should only be called for Rook or Bishop
    };

    let mut attacks = Bitboard::EMPTY;
    let mut i = 0;
    // Loop through the directions for the piece type
    while i < dirs.len() {
        let mut to = sq;
        // Loop along the ray direction
        loop {
            // Try to move one step in the current direction
            to = match to.add(dirs[i]) {
                Ok(next_sq) => next_sq,
                Err(_) => break, // Stop if we hit the edge of the board
            };
            // Add the new square to the attacks
            attacks.bitor_assign(to.bb());
            // Stop if the new square is occupied (it blocks further attacks)
            if occ.get(to) {
                break;
            }
        }
        i += 1;
    }
    attacks
}

/******************************************\
|==========================================|
|        Populating Magic Parameters       |
|==========================================|
\******************************************/

/// Populates the `MagicTable` with calculated parameters (`mask`, `shift`, `offset`).
///
/// This `const fn` is executed at compile time. It takes the pre-generated magic numbers
/// (imported from `lookup::*_MAGIC_NUMS`) and calculates the corresponding mask, shift,
/// and offset for each square's `Magic` entry. The resulting `MagicTable` is used
/// at runtime (via `lookup::*_MAGICS`) to perform the index calculation for the
/// precomputed attack tables (`lookup::*_TABLE`).
///
/// # Arguments
/// * `pt`: The `PieceType` (must be `Rook` or `Bishop`).
///
/// # Returns
/// A `MagicTable` ([Magic; 64]) containing the calculated parameters for each square.
///
/// # Panics
/// Panics at compile time if `pt` is not `PieceType::Bishop` or `PieceType::Rook`.
pub(super) const fn populate_magic_table(pt: PieceType) -> MagicTable {
    let mut offset = 0;
    let mut magic = [Magic::EMPTY; Square::NUM];

    // Select the appropriate pre-generated magic numbers (included via build.rs -> lookup.rs)
    let magic_numbers = match pt {
        PieceType::Bishop => BISHOP_MAGIC_NUMS,
        PieceType::Rook => ROOK_MAGIC_NUMS,
        _ => unreachable!(),
    };

    let mut i = 0;
    while i < Square::NUM {
        let sq = unsafe { Square::from_unchecked(i as u8) };

        // Calculate the mask: potential attacks on an empty board, excluding edges.
        let mask = attacks_on_the_fly(pt, sq, Bitboard::EMPTY).bitand(get_edge_mask(sq).not());
        // Calculate the shift: 64 minus the number of relevant blocker squares (bits in the mask).
        let shift = 64 - mask.count_bits() as u8;

        // Create the Magic entry for this square
        let m = Magic {
            magic: magic_numbers[i], // Use the pre-generated magic number
            mask,                    // Use the calculated mask
            shift,                   // Use the calculated shift
            offset,                  // Use the current offset
        };

        // Store the calculated Magic entry
        magic[i] = m;

        // Update the offset for the next square's entries in the global attack table.
        // The size required for this square's entries is 2^(number of bits in mask).
        offset += 1 << mask.count_bits();

        i += 1;
    }

    magic // Return the fully populated table of Magic entries
}

/******************************************\
|==========================================|
|            Helper Functions              |
|==========================================|
\******************************************/

/// Calculates a mask representing the edges of the board relevant to a given square.
///
/// This mask is used to exclude squares on the absolute edges (Rank 1/8, File A/H)
/// from a piece's attack `mask` during magic parameter calculation (`populate_magic_table`).
/// Blockers on these edge squares generally don't affect the attack set for squares
/// further inside the board in a way that requires different magic table entries.
///
/// However, if the attacking piece (`sq`) is itself on an edge rank or file, that
/// rank/file is *not* included in the returned edge mask, because blockers *on that line*
/// are relevant.
///
/// # Arguments
/// * `sq`: The `Square` from which the piece is attacking.
///
/// # Returns
/// A `Bitboard` mask representing the relevant board edges to exclude.
pub(crate) const fn get_edge_mask(sq: Square) -> Bitboard {
    use File::*;
    use Rank::*;

    // Bitboards for Rank 1/8 and File A/H
    let rank_18bb: Bitboard = Rank1.bb().bitor(Rank8.bb());
    let file_ahbb: Bitboard = FileA.bb().bitor(FileH.bb());

    // Bitboards for the specific rank and file of the square `sq`
    let sq_rank_bb = sq.rank().bb();
    let sq_file_bb = sq.file().bb();

    // Calculate rank mask: Ranks 1 and 8, *unless* sq is on that rank.
    let rank_mask = rank_18bb.bitand(sq_rank_bb.not());
    // Calculate file mask: Files A and H, *unless* sq is on that file.
    let file_mask = file_ahbb.bitand(sq_file_bb.not());

    // Combine the rank and file masks
    rank_mask.bitor(file_mask)
}
